import fs from 'fs';

class Utils {
    static capitalizeAndRemoveHighDash(str: string) {
        return str.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('');
    }

    static createFile(outfile: string, content: any) {
        const subfolders = outfile.substring(0, outfile.lastIndexOf("/"));

        // Check if the subfolders exist, and create them if they do not
        if (!fs.existsSync(subfolders)) {
            fs.mkdirSync(subfolders, { recursive: true });
        }

        // Create the file
        fs.writeFileSync(outfile, content);
    }

    /**
     * recursive builder. builds all properties to large object under baseRoute.
     * @param baseRoute BaseRoute
     * @param routes any
     */
    static buildRoutes(baseRoute: BaseRoute, routes: any) {
        for (const [route, subRoutes] of Object.entries(routes)) {
            if (subRoutes === null) {
                baseRoute.addDirectChild(route);
            } else {
                const routeCls = new BaseRoute(route, `${baseRoute.path}/${route}`, baseRoute.depth + 1);
                baseRoute.addDeepChild(routeCls);
                this.buildRoutes(routeCls, subRoutes);
            }
        }
    }
}

class BaseRoute {
    depth: number = 0;
    path = '';
    namespace = '';
    directChildren: string[] = [];
    deepChildren: BaseRoute[] = [];

    constructor(name: string, path: string, depth: number) {
        this.namespace = Utils.capitalizeAndRemoveHighDash(name);
        this.path = path;
        this.depth = depth;
    }

    indent(control: number = 0) {
        return '    '.repeat(this.depth + 1 + control);
    }

    addDirectChild(child: string) {
        this.directChildren.push(child);
    }

    addDeepChild(child: BaseRoute) {
        this.deepChildren.push(child);
    }

    stringifyPath() {
        return `export const path = "${this.path}";\n`;
    }

    stringifyDirectChildren() {
        return this.directChildren.map(child => `export const ${Utils.capitalizeAndRemoveHighDash(child)} = { path: "${this.path}/${child}" };`).join('\n' + this.indent());
    }

    stringifyDeepChildren(): string {
        return this.deepChildren.map(child => child.stringifyToNamespace()).join('\n\n' + this.indent());
    }

    stringifyToNamespace() {
        let namespace = `export namespace ${this.namespace} {
${this.indent()}${this.stringifyPath()}
${this.indent()}${this.stringifyDirectChildren()}
${this.indent()}${this.stringifyDeepChildren()}
${this.indent(-1)}}`;

        if (this.namespace === 'Routes') {
            namespace = namespace.replace('const path = ""', 'const path = "/"');
        }

        return namespace;
    }
}

// get json file from command line
const jsonFileInput = process.argv[2];
if (!fs.existsSync(jsonFileInput)) {
    console.error(`File ${jsonFileInput} does not exist`);
    process.exit(1);
}

// read json file
const routesJson = JSON.parse(fs.readFileSync(jsonFileInput, 'utf8'));
if (!routesJson.domain) {
    console.error('Domain is required');
    process.exit(1);
}

// create root object
const root = new BaseRoute('Routes', routesJson.domain, 0);

// create all routes recursively under the root object
Utils.buildRoutes(root, routesJson.routes);

// stringify the root object to namespace
let routesNs: string = root.stringifyToNamespace();

// add warning to top of file to not edit directly
routesNs = `// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n\n${routesNs}`;

// use in default location if outfile not provided
const outfile = !!routesJson.outfile ? routesJson.outfile : './dist/routes.ns.ts';
Utils.createFile(outfile, routesNs);